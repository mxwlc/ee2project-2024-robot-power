================================================
Header Files
================================================
--------------------
include/column_overlay.hpp
--------------------
//
// Created by maxwe on 08/06/24.
//

#ifndef EE2_COMPUTER_VISION_COLUMN_OVERLAY_HPP
#define EE2_COMPUTER_VISION_COLUMN_OVERLAY_HPP

#include "overlay.hpp"
#include <opencv2/imgproc.hpp>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>

namespace overlay
{
	class column_overlay : public overlay
	{
	 private:
		int padding;

	 public:
		column_overlay();

		column_overlay(int padding);

		int GetPadding() const;

		uchar position(cv::Point2f &pt);

		uchar marker_position(std::vector<cv::Point2f> &m);

		std::string print() const;

		bool within_bounds(std::vector<cv::Point2f>& marker);

		bool point_in_bounds(cv::Point2f point) const;

		void draw(cv::Mat& m);
	};

	std::ostream& operator<<(std::ostream& os, column_overlay const& o);
}
#endif //EE2_COMPUTER_VISION_COLUMN_OVERLAY_HPP
--------------------
include/marker_dict.hpp
--------------------


#ifndef EE2_COMPUTER_VISION_MARKER_DICT_HPP
#define EE2_COMPUTER_VISION_MARKER_DICT_HPP

#include <fstream>
#include <iostream>
#include <map>
#include <opencv2/objdetect/aruco_detector.hpp>
#include <opencv2/opencv.hpp>

#pragma once
namespace dictionary
{
/*
This needs changing to add for more "jobs"
*/
	typedef enum
	{
		STOP = 0, FORWARD = 1, BACKWARD = 2, TURN_L = 3, TURN_R = 4, STATES_NR_ITEMS = 5
	} states;

	class marker_dict
	{
	 private:

		// internal MarkID -> State mapping
		std::map<int, states> marker_map;

		// maps State to the corresponding label
		std::map<states, std::string> enum_to_string = {{ states::STOP, "STOP" }, { states::FORWARD, "FORWARD" },
			{ states::BACKWARD, "BACKWARD" }, { states::TURN_L, "TURN_L" }, { states::TURN_R, "TURN_R" },
			{ states::STATES_NR_ITEMS, std::to_string(int(states::STATES_NR_ITEMS)) }};

	 public:
		// Constructors
		marker_dict();

		marker_dict(std::map<int, states>& dict);

		marker_dict(std::string filename);

		// Destructor
		~marker_dict();

		// Add {marker_id, state} pair to the internal marker map
		void add_marker(int id, states marker_state);

		// returns the state for a given id
		states marker_translate(int id);

		// debug : output entire map
		std::map<int, states> return_dict() const;

		// debug : prints the marker map hash
		std::string print_dict() const;

		// Stores the internal marker_map locally
		void save_dict();

		// debug : translates state enums to a corresponding string
		std::string enum_string_translation(states in_state);

		// returns the size of the internal marker map
		int size_of_map();

		// Read marker_map from a file
		std::map<int, states> load_marker_map(std::string filename);
	};

// Cout class#
	std::ostream& operator<<(std::ostream& os, marker_dict const& m);
}

#endif //EE2_COMPUTER_VISION_MARKER_DICT_HPP--------------------
include/overlay.hpp
--------------------
//
// Created by maxwe on 08/06/24.
//
#ifndef EE2_COMPUTER_VISION_OVERLAY_HPP
#define EE2_COMPUTER_VISION_OVERLAY_HPP

#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/videoio.hpp>
#include <map>

#define quote(x) #x

namespace overlay
{

	static int WINDOW_HEIGHT = 480;
	static int WINDOW_WIDTH = 640;
	static bool DEBUG_FLAG;

	static std::map<uchar, std::string> position_translation = {
		std::pair<uchar, std::string>(0b0000, std::string("Invalid")),
		std::pair<uchar, std::string>(0b0100, std::string("Left")),
		std::pair<uchar, std::string>(0b0110, std::string("Left-Middle")),
		std::pair<uchar, std::string>(0b0010, std::string("Middle")),
		std::pair<uchar, std::string>(0b0011, std::string("Right-Middle")),
		std::pair<uchar, std::string>(0b0001, std::string("Right")),
		std::pair<uchar, std::string>(0b0111, std::string("Invalid")), };

	class overlay
	{
	 protected:
		int window_height;
		int window_width;
	 public:
		overlay();

		virtual ~overlay();

		virtual bool within_bounds();

		virtual bool point_in_bounds();

		virtual std::string print() const;

		virtual void draw();

		virtual uchar position();
	};

	std::ostream& operator<<(std::ostream& os, overlay const& o);

}
#endif //EE2_COMPUTER_VISION_OVERLAY_HPP
--------------------
include/square_overlay.hpp
--------------------
//
// Created by maxwe on 07/06/24.
//
#pragma once

#ifndef EE2_COMPUTER_VISION_SQUARE_OVERLAY_HPP
#define EE2_COMPUTER_VISION_SQUARE_OVERLAY_HPP

#include<opencv2/core.hpp>
#include<map>
#include<iostream>
#include "overlay.hpp"

namespace overlay
{
	class square_overlay : public overlay
	{
	 public:
		square_overlay() = default;

		square_overlay(std::vector<cv::Point2f>&);

		explicit square_overlay(int side_length);

		bool within_bounds(std::vector<cv::Point2f>& marker);

		bool point_in_bounds(cv::Point2f v);

		void draw(cv::Mat& m);

		std::vector<cv::Point2f> getCorners() const;

		std::string print() const;
	 private:
		std::vector<cv::Point2f> corners;
		int side_length;
	};
	std::ostream& operator<<(std::ostream& os, square_overlay const& so);
}
#endif //EE2_COMPUTER_VISION_SQUARE_OVERLAY_HPP
================================================
Source Files
================================================
--------------------
src/column_overlay.cpp
--------------------
//
// Created by maxwe on 08/06/24.
//

#include "column_overlay.hpp"
namespace overlay
{
	column_overlay::column_overlay()
	{
		padding = 0;
	}

	column_overlay::column_overlay(int padding_) : padding(padding_)
	{
	}

	int column_overlay::GetPadding() const
	{
		return padding;
	}

	bool column_overlay::point_in_bounds(cv::Point2f point) const
	{
		if (point.x < (float)padding)
		{
			return false;
		}
		if (point.x > (float)(window_width - padding))
		{
			return false;
		}
		return true;
	}

	bool column_overlay::within_bounds(std::vector<cv::Point2f>& marker)
	{
		bool inside = false;
		for (cv::Point2f vertex : marker)
		{
			inside = point_in_bounds(vertex);
			if (!inside) return false;
		}
		return inside;
	}

	void column_overlay::draw(cv::Mat& m)
	{
		auto padding_f = (float)padding;
		auto window_width = (float)WINDOW_WIDTH;
		auto window_height = (float)WINDOW_HEIGHT;
		if (DEBUG_FLAG) std::cout << "Draw Column Overlay\n";
		cv::line(m, cv::Point2f(padding_f, 0.0), cv::Point2f(padding_f, window_height), cv::Scalar(0, 255, 0), 2);
		cv::line(m, cv::Point2f((window_width - padding_f), 0.0), cv::Point2f(
			window_width - padding_f, window_height), cv::Scalar(0, 255, 0), 2);
	}

	std::string column_overlay::print() const
	{
		std::string output;
		output = std::string(quote(column_overlay)) + std::string("\n") + std::string("Padding : ")
				 + std::to_string(GetPadding()) + "\n";
		return output;
	}
	uchar column_overlay::position(cv::Point2f& pt)
	{
		if (pt.x < (float)padding)
		{
			return 0b0100;
		}
		if (pt.x > (float)(window_width - padding))
		{
			return 0b0001;
		}
		return 0b0010;
	}
	uchar column_overlay::marker_position(std::vector<cv::Point2f>& m)
	{
		uchar valid = 0b0000;
		for (auto& vertex : m)
		{
			valid = valid | position(vertex);
		}
		return valid;
	}

	std::ostream& operator<<(std::ostream& os, const column_overlay& o)
	{
		std::string output;
		output = o.print();
		return os << output;
	}
}
--------------------
src/marker_detect.cpp
--------------------
//
// Created by maxwe on 25/05/24.
//

#include "../include/column_overlay.hpp"
#include "../include/marker_dict.hpp"
#include "../include/square_overlay.hpp"
#include <ctime>
#include <iostream>
#include <map>
#include <opencv2/highgui.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/videoio.hpp>
#include <sstream>

#define MARKER_EDGE_SIZE = 200
#define BORDER_SIZE = 1
#define ARUCO_DICTIONARY cv::aruco::DICT_5X5_1000

class target
{
 public:
	std::vector<std::vector<cv::Point2f>> target_coords;
	std::vector<int> target_id;

	target()
	{
		cv::Point2f zero = cv::Point2f(0, 0);
		std::vector<cv::Point2f> marker = { zero };
		std::vector<std::vector<cv::Point2f>> mmarker = { marker };

		target_coords = mmarker;
		target_id = { 0 };
	}
	target(std::vector<std::vector<cv::Point2f>> target_coords_, std::vector<int> target_id_)
		: target_id(target_id_), target_coords(target_coords_)
	{
	}

	void set_target(std::vector<std::vector<cv::Point2f>> target_coords_, std::vector<int> target_id_)
	{
		target_coords = target_coords_;
		target_id = target_id_;

	}

	std::vector<std::vector<cv::Point2f>> get_target_coords()
	{
		return target_coords;
	}

	std::vector<int> get_target_id()
	{
		return target_id;
	}
};

std::vector<int> translate_found_markers(std::unique_ptr<dictionary::marker_dict>& md, std::vector<int>& input_ids)
{
	std::vector<int> marker_states;
	for (int input_id : input_ids)
	{
		marker_states.push_back(int(md->marker_translate(input_id)));
	}
	return marker_states;
}

std::string gen_file_name_formatted(const std::string& key, const std::string& file_type)
{
	std::time_t t = std::time(nullptr);
	std::tm* now = std::localtime(&t);
	std::ostringstream datestream;
	datestream << std::put_time(now, "-%d%m%y-%H%M");
	return "output/" + key + datestream.str() + "." + file_type;
}

int main()
{
	overlay::DEBUG_FLAG = false;
	bool target_flag = false;
	bool ids_flag = false;
	bool location_flag = false;
	cv::Mat frame;

	overlay::square_overlay sq_o(200);
	overlay::column_overlay c_o(200);

	if (overlay::DEBUG_FLAG) std::cout << "Square Overlay Initialised\n";
	std::unique_ptr<dictionary::marker_dict> md(new dictionary::marker_dict("marker_dict"));

	int id;
	std::cout << "Target id = ";
	std::cin >> id;

	// -- verify marker dict has been loaded properly --
	if (md->size_of_map() <= 1)
	{
		std::cerr << "Error : marker_dict no initialised properly\n";
		return 1;
	}

	// -- Video Capture Init --
	cv::VideoCapture cap;
	cap.open(-1);
	if (!cap.isOpened())
	{
		std::cerr << "Error : Unable to open Camera\n";
		return -1;
	}
	cv::aruco::DetectorParameters detector_params = cv::aruco::DetectorParameters();
	cv::aruco::Dictionary dict = cv::aruco::getPredefinedDictionary(ARUCO_DICTIONARY);
	cv::aruco::ArucoDetector detector(dict, detector_params);

	std::cout << "Press any Key to Start\n";

	// -- Main Loop --
	std::cout << "Press any key to terminate\n";
	for (;;)
	{
		cap.read(frame);
		int key_press = cv::waitKey(5);
		// -- validate frame --
		if (frame.empty())
		{
			std::cerr << "Error : Blank Frame Grabbed\n";
			break;
		}

		std::vector<int> marker_ids;
		std::vector<std::vector<cv::Point2f>> marker_corners, rejected_candidates;

		detector.detectMarkers(frame, marker_corners, marker_ids, rejected_candidates);

		if (!marker_ids.empty() && overlay::DEBUG_FLAG)
		{
			for (int i = 0; i < marker_ids.size(); ++i)
			{
				std::cout << marker_ids[i] << '\n';
				int k = 0;
				for (auto corner : marker_corners[i])
				{
					std::cout << "Point " << k << " : " << "( " << corner.x << ", " << corner.y << ")" << "\n";
					k++;
				}
			}
		}

		std::vector<int> marker_states = translate_found_markers(md, marker_ids);

		// Draw Polygon Boundaries
		sq_o.draw(frame);
		c_o.draw(frame);
		int t_j;

		std::vector<std::vector<cv::Point2f>> t_coord;

		if (!marker_ids.empty())
		{
			for (int j = 0; j < marker_ids.size(); j++)
			{
				if (marker_ids[j] == id)
				{
					t_coord = { marker_corners[j] };
//						target_marker->set_target({ marker_corners[j] }, std::vector<int>(marker_ids[j]))
					std::cout << "Found Target " << id << "\n";
				}
			}
		}

		if (overlay::DEBUG_FLAG)
		{
			for (int i = 0; i < marker_ids.size(); i++)
			{
				std::cout << "\nid = " << marker_ids[i] << "\nSquare : " << sq_o.within_bounds(marker_corners[i])
						  << "\nColumn : " << c_o.within_bounds(marker_corners[i]) << "\nPos : "
						  << overlay::position_translation[c_o.marker_position(marker_corners[i])];
			}
		}

		if (location_flag)
		{
			if (target_flag)
			{
				marker_corners = t_coord;
				marker_ids = { id };

			}
			if (!marker_corners.empty())
			{
				for (int i = 0; i < marker_ids.size(); i++)
				{
					std::cout << i << ") ";
					std::cout << "id=" << marker_ids[i] << " pos : "
							  << overlay::position_translation[c_o.marker_position(marker_corners[i])] << "\n";
				}
			}
		}
		if (target_flag)
		{
			if (!marker_ids.empty())
			{
				std::vector<std::vector<cv::Point2f>> t_corner = t_coord;
				std::vector<int> t_id = { id };
				std::vector<int> t_state = translate_found_markers(md, t_id);
				if (!t_corner.empty() && !t_id.empty())
				{
					if (ids_flag) cv::aruco::drawDetectedMarkers(frame, t_corner, t_id);
					else cv::aruco::drawDetectedMarkers(frame, t_corner, t_state);
				}
			}
		}
		else
		{
			if (ids_flag) cv::aruco::drawDetectedMarkers(frame, marker_corners, marker_ids);
			else cv::aruco::drawDetectedMarkers(frame, marker_corners, marker_states);
		}
		cv::imshow("Live", frame);

		// --  close window when key pressed --
		if (key_press == (int)'i')
		{
			std::cout << "Toggle ID/METHOD\n";
			ids_flag = !ids_flag;
		}
		else if (key_press == (int)'l')
		{
			std::cout << "Toggle Locations (l/r/m)\n";
			location_flag = !location_flag;
		}
		else if (key_press == (int)'t')
		{
			std::cout << "Toggle Target\n";
			target_flag = !target_flag;
		}
		else if (key_press >= 0)
		{
			if (key_press == int('s'))
			{
				std::string format_str = gen_file_name_formatted("webcam", "bmp");
				std::cout << "Saving to " << format_str << "\n";
				cv::imwrite(format_str, frame);
			}
			break;
		}
	}

	return 0;
}

--------------------
src/marker_detect_image.cpp
--------------------
//
// Created by maxwe on 27/05/24.
//
#include <fstream>
#include <iostream>
#include <map>
#include <opencv2/objdetect/aruco_board.hpp>
#include <opencv2/objdetect/aruco_detector.hpp>
#include <opencv2/opencv.hpp>
#include "../include/marker_dict.hpp"

#define MARKER_EDGE_SIZE = 200
#define BORDER_SIZE = 1
#define ARUCO_DICTIONARY cv::aruco::DICT_5X5_1000

int main()
{
	cv::Mat input_image;
	cv::Mat raw_image;
	int down_height = 600;
	int down_width = down_height * 4 / 3;
	raw_image = cv::imread("doc/arucofieldtest.jpg");
	cv::resize(raw_image, input_image, cv::Size(down_width, down_height), cv::INTER_LINEAR);
	cv::imshow("Test", input_image);
	std::cout << input_image.size() << std::endl;
	cv::waitKey(0);
	if (!input_image.data)
	{
		exit(1);
	}
	std::vector<int> marker_ids;
	std::vector<std::vector<cv::Point2f>> marker_corners, rejected_candidates;
	cv::aruco::DetectorParameters detector_params = cv::aruco::DetectorParameters();
	cv::aruco::Dictionary dict = cv::aruco::getPredefinedDictionary(ARUCO_DICTIONARY);
	cv::aruco::ArucoDetector detector(dict, detector_params);
	detector.detectMarkers(input_image, marker_corners, marker_ids, rejected_candidates);
	cv::Mat output_image;
	output_image = input_image.clone();
	cv::aruco::drawDetectedMarkers(output_image, marker_corners, marker_ids);
	cv::imshow("Detected", output_image);
	cv::waitKey(0);
	cv::imwrite("output/detected_image.bmp", output_image);
}

--------------------
src/marker_dict.cpp
--------------------
#include "../include/marker_dict.hpp"
// TODO write comments and documentation

namespace dictionary {
    marker_dict::marker_dict()
    {
        /*
         * Default constructor, initialises the map with a {0, STOP} pair
         */
        std::cout << "Marker Dictionary Initialisation Start" << std::endl;
        std::map<int, states> temp_map({{0, states::STOP}});
        marker_map = temp_map;
        std::cout << "Marker Dictionary Initialisation End" << std::endl;
    }

    marker_dict::marker_dict(std::map<int, states>& dict)
    {
        /*
         * Constructor setting the internal map to the provided arguement map
         */
        marker_map = dict;
    }

    marker_dict::marker_dict(std::string filename)
    {
        /*
         * Constructor, setting marker map to the map stored in the provided text file
         */
        std::map<int, states> t_marker_map;
        marker_map = load_marker_map(filename);
    }

    marker_dict::~marker_dict()
    {
        // Debug atm
        // Destructor that tells the user when the marker dict object (and thus the shared_ptr to the object) leaves the current scope (or the ptr is deleted)
        std::cout << "Marker Dictionary Leaves Scope" << std::endl;
    }

    void marker_dict::add_marker(int id, states marker_state)
    {
        /*
         * Adds a {marker_id, state} Pair to the internal map
         */
        marker_map.insert({id, marker_state});
    }

    states marker_dict::marker_translate(int id)
    {
        /*
         * Returns the corresponding enum State from the provided marker id
         */
        return marker_map[id];
    }

    std::map<int, states> marker_dict::return_dict() const
    {
        /*
         * Returns the internal marker map object
         */
        return marker_map;
    }

    std::string marker_dict::print_dict() const
    {
        /*
         * Debug print
         * May haps be useless
         */
        std::string output;
        std::string line;
        output = std::string("ID, State \n")+std::string("{\n");
        for (auto& t : marker_map) {
            line = std::to_string(t.first)+std::string(" : ")+std::to_string(states(t.second))+std::string("\n");
            output.append(line);
        }
        output.append("}\n");
        return output;
    }

    void marker_dict::save_dict()
    {
        std::string filename("marker_dict");
        std::ofstream outfile(filename);

        if (!outfile.is_open()) {
            std::cerr << "Failed to open file for writing: " << filename << std::endl;
            return;
        }
        for (const auto& pair : marker_map) {
            outfile << pair.first << " " << pair.second << std::endl;
        }

        outfile.close();

        if (!outfile.good()) {
            std::cerr << "Error occurred at writing time!" << std::endl;
        }
    }

    int marker_dict::size_of_map()
    {
        return (int)marker_map.size();
    }

    std::map<int, states> marker_dict::load_marker_map(std::string filename)
    {
        std::ifstream input_file(filename);
        std::map<int, states> marker_map_in;
        if (!input_file) {
            std::cerr << "Error : Cannot open file\n";
            marker_map_in.insert({{0, states::STOP}});
            return marker_map_in;
        }
        std::string key, value;
        while (input_file >> key >> value) {
            marker_map_in[std::stoi(key)] = (states) std::stoi(value);
        }
        return marker_map_in;
    }

    std::string marker_dict::enum_string_translation(states in_state)
    {
        return enum_to_string[in_state];
    }

    std::ostream& operator<<(std::ostream& os, marker_dict const& m)
    {
        std::string output = m.print_dict();
        return os << output;
    }
}
--------------------
src/marker_gen.cpp
--------------------
//
// Created by maxwe on 27/05/24.
//
#include <cmath>
#include <fstream>
#include <iostream>
#include <map>
#include <opencv2/objdetect/aruco_board.hpp>
#include <opencv2/objdetect/aruco_detector.hpp>
#include <opencv2/opencv.hpp>
#include "../include/marker_dict.hpp"

#define MARKER_EDGE_SIZE  200
#define BORDER_SIZE  1
#define ARUCO_DICTIONARY cv::aruco::DICT_5X5_250
#define MAX_MARKER_NUMBER 250

std::vector<uchar> id_array()
{
	std::cout << "-------------------------------------------------------------------------------" << std::endl;
	bool valid = false;
	int total_marker;
	do
	{
		std::cout << "Please insert the total Number of Markers You would Like to generate (1-10): ";
		std::cin >> total_marker;
		if (std::cin.fail())
		{
			std::cout << std::endl << "Please Enter a Valid Number" << std::endl;
			valid = false;
		}
		else if (total_marker > 10 || total_marker < 1)
		{
			std::cout << std::endl << "Please Enter A number within the range (1-10)" << std::endl;
			valid = false;
		}
		else
		{
			valid = true;
		}
		std::cin.clear();
		std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	} while (!valid);

	std::cout << "-------------------------------------------------------------------------------" << std::endl
			  << "You are generating " << total_marker << " marker(s)" << std::endl
			  << "-------------------------------------------------------------------------------" << std::endl;
	std::vector<uchar> marker_ids;

	for (int i = 0; i < total_marker; i++)
	{
		valid = false;
		int current_id;
		do
		{
			std::cout << "Please insert the ID for marker " << (i + 1) << std::endl;
			std::cin >> current_id;
			if (std::cin.fail())
			{
				std::cout << std::endl << "Please Enter a Valid Number" << std::endl;
				valid = false;
			}
			else if (total_marker > MAX_MARKER_NUMBER || total_marker < 0)
			{
				std::cout << std::endl << "Please Enter A number within the range (0-255)" << std::endl;
				valid = false;
			}
			else
			{
				valid = true;
				marker_ids.push_back(current_id & 0xff);
			}
			std::cin.clear();
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		} while (!valid);
	}
	return marker_ids;
}

void add_to_dictionary(dictionary::marker_dict& dict, int id)
{
/* Needs changing to support a variable enum size
 *
 * */



	int choice;
	bool valid = false;
	do
	{
		std::cout << "What Should Marker (id =" << id << ") Do" << std::endl;
		std::cout << "-------------------------------------------------------------------------------" << std::endl;
		// Print Menu
		for (int i = 0; i < (int)dictionary::states::STATES_NR_ITEMS; i++)
		{
			std::cout << i << "\n";
		}

		std::cout << "-------------------------------------------------------------------------------" << std::endl;
		std::cin >> choice;
		if (std::cin.fail())
		{
			std::cout << std::endl << "Please Enter a Valid Number" << std::endl;
			valid = false;
		}
		else if (choice > 4 || choice < 0)
		{
			std::cout << std::endl << "Please Enter A valid choice (0-4)" << std::endl;
			valid = false;
		}
		else
		{
			valid = true;
		}
		std::cin.clear();
		std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	} while (!valid);
	dictionary::states curr_state;
	switch (choice)
	{
	case 0:
		curr_state = dictionary::states::STOP;
		break;
	case 1:
		curr_state = dictionary::states::FORWARD;
		break;
	case 2:
		curr_state = dictionary::states::BACKWARD;
		break;
	case 3:
		curr_state = dictionary::states::TURN_L;
		break;
	case 4:
		curr_state = dictionary::states::TURN_R;
		break;
	default:
		curr_state = dictionary::states::STOP;
		break;
	}
	dict.add_marker(id, curr_state);
}

int main()
{
	std::cout << "-------------------------------------------------------------------------------" << std::endl
			  << "Marker Generator" << std::endl
			  << "-------------------------------------------------------------------------------" << std::endl;
	std::shared_ptr<dictionary::marker_dict> md(new dictionary::marker_dict());

	std::cout << "-------------------------------------------------------------------------------" << std::endl
			  << "Loading Predefined Dictionary" << std::endl
			  << "-------------------------------------------------------------------------------" << std::endl;
	cv::aruco::Dictionary dict = cv::aruco::getPredefinedDictionary(ARUCO_DICTIONARY);

	std::cout << "-------------------------------------------------------------------------------" << std::endl;
	std::cout << "Dictionary Initiated at memory address " << &md << std::endl;
	std::cout << "-------------------------------------------------------------------------------" << std::endl;

	std::vector<uchar> curr_id_array = id_array();
	std::cout << "-------------------------------------------------------------------------------" << std::endl
			  << "Id Array Size : " << curr_id_array.size() << std::endl
			  << "-------------------------------------------------------------------------------" << std::endl;

	for (unsigned char i : curr_id_array)
	{

		cv::Mat marker;
		uchar id = i;
		std::cout << "Generating Marker With id = " << int(i) << std::endl;
		cv::aruco::generateImageMarker(dict, i, MARKER_EDGE_SIZE, marker, BORDER_SIZE);
		std::string marker_filename = "markers/marker_id" + std::to_string(int(id)) + ".bmp";
		cv::imwrite(marker_filename, marker);
		std::cout << "-------------------------------------------------------------------------------" << std::endl;
		std::cout << "Starting state selection logic" << std::endl;
		add_to_dictionary(*md, id);
		std::cout << "-------------------------------------------------------------------------------" << std::endl;
	}

	md->print_dict();
	std::cout << *md << std::endl;
	md->save_dict();
	return 0;
}

--------------------
src/overlay.cpp
--------------------
//
// Created by maxwe on 08/06/24.
//
#include "../include/overlay.hpp"

namespace overlay {
    overlay::overlay()
    {
        window_height = WINDOW_HEIGHT;
        window_width = WINDOW_WIDTH;
    }

    overlay::~overlay() { }

    bool overlay::within_bounds()
    {
        return false;
    }

	std::string overlay::print() const
	{

		return { quote(overlay)};
	};

    void overlay::draw(){};

	bool overlay::point_in_bounds()
	{
		return false;
	}
	uchar overlay::position(){
		return 0b111;
	}

	std::ostream& operator<<(std::ostream& os, overlay const& o)
    {
		std::string output = o.print();
        return os << output;
    }
}
--------------------
src/square_overlay.cpp
--------------------
//
// Created by maxwe on 07/06/24.
//

#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>

#include "../include/square_overlay.hpp"

namespace overlay
{
	square_overlay::square_overlay(std::vector<cv::Point2f>& corners_in)
	{
		cv::Point2f p1 = corners_in[0];
		cv::Point2f p2 = corners_in[1];

		side_length = (int)cv::norm(p1 - p2);
		corners = corners_in;
		window_height = WINDOW_HEIGHT;
		window_width = WINDOW_WIDTH;
	}

	square_overlay::square_overlay(int side_length_in)
	{
		if (DEBUG_FLAG) std::cout << "square_overlay(int side_length)\n";
		auto window_width_f = (float)window_width;
		auto window_height_f = (float)window_height;
		auto x_0 = (float)(window_width_f / 2);
		auto y_0 = (float)(window_height_f / 2);
		auto half_len = (float)((float)side_length_in / (float)2);
		cv::Point2f origin = cv::Point2f(x_0, y_0);

		std::vector<cv::Point2f> box_vertices = { cv::Point2f(half_len, half_len), cv::Point2f(half_len, -half_len),
			cv::Point2f(-half_len, -half_len), cv::Point2f(-half_len, half_len) };
		for (auto& vertex : box_vertices)
		{
			vertex += origin;
		}
		corners = box_vertices;
		side_length = side_length_in;
	}

	bool square_overlay::within_bounds(std::vector<cv::Point2f>& marker)
	{
		bool inside = true;
		for (auto corner : marker)
		{
			inside = point_in_bounds(corner);
			if (!inside)
			{
				return inside;
			}
		}
		return inside;
	}

	bool square_overlay::point_in_bounds(cv::Point2f v)
	{
		cv::Point2f p1 = corners[1];
		cv::Point2f p2 = corners[3];
		if (DEBUG_FLAG)
		{
			std::cout << "\np1 : " << p1 << "\n";

			std::cout << "p2 : " << p2 << "\n";
			std::cout << v.x << "<" << p1.x << "\n" << v.x << ">" << p2.x << "\n" << v.y << "<" << p1.y << "\n" << v.y
					  << ">" << p2.y << "\n";
		}
		if (v.x < p1.x and v.x > p2.x and v.y > p1.y and v.y < p2.y)
		{
			return true;
		}
		return false;
	}

	std::vector<cv::Point2f> square_overlay::getCorners() const
	{
		return corners;
	}

	void square_overlay::draw(cv::Mat& m)
	{
		// God knows why this is an issue :3

		if (DEBUG_FLAG) std::cout << "Draw Square Overlay\n";

		// Poly lines only accepts integer points
		std::vector<cv::Point2i> IntCornersVec;
		cv::Mat FloatCorners(corners);
		cv::Mat IntCorners;
		FloatCorners.convertTo(IntCorners, CV_32S);
		IntCorners.copyTo(IntCornersVec);
		if (corners.size() > 1)
		{
			if (!IntCorners.empty())
			{
				cv::polylines(m, IntCorners, true, cv::Scalar(0, 255, 0), 2);
			}
		}
	}
	std::string square_overlay::print() const
	{
		std::string output;
		output = std::string(quote(square_overlay)) + "\n";
		std::vector<cv::Point2f> vertices = getCorners();
		for (auto vertex : vertices)
		{
			output += ("(" + std::to_string(vertex.x) + ", " + std::to_string(vertex.y) + ")\n");
		}
		return output;
	}

	std::ostream& operator<<(std::ostream& os, const square_overlay& so)
	{
		std::string output = so.print();
		return os << output;
	}
}
--------------------
src/test_writing.cpp
--------------------
//
// Created by maxwe on 06/06/24.
//
#include <iostream>
#include <opencv2/core.hpp>
#include "../include/square_overlay.hpp"
#include "../include/overlay.hpp"
#include "../include/column_overlay.hpp"
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>

int main()
{
	overlay::DEBUG_FLAG = true;

	cv::Mat m = cv::Mat::zeros(overlay::WINDOW_HEIGHT, overlay::WINDOW_WIDTH, CV_8UC3);
	overlay::square_overlay sq_o(200);
	overlay::column_overlay c_o(250);
	std::vector<cv::Point2f> v({cv::Point2f(300, 300), cv::Point2f(310, 300), cv::Point2f(300, 310), cv::Point2f(310, 310)});
	sq_o.draw(m);
	c_o.draw(m);
	std::cout << "------------------------\n";
	std::cout << c_o << std::endl;
	std::cout << "------------------------\n";
	std::cout << sq_o << std::endl;
	std::cout << "------------------------\n";
	std::cout << "------------------------\n" << "DEBUG SQUARE\n";
	for (auto corner : v)
	{
		std::cout << corner << "\n";
		cv::circle(m, corner, 10, cv::Scalar(0, 255, 0), 3);
	}
	std::cout << "DEBUG SQUARE - Done\n";

	std::cout << "------------------------\n" << "BOUNDARY SQUARE\n";
	auto corners = sq_o.getCorners();
	for (auto corner : corners)
	{
		std::cout << corner << "\n";
		cv::circle(m, corner, 10, cv::Scalar(0, 255, 0), 3);
	}
	std::cout << "BOUNDARY SQUARE - Done\n";

	cv::imshow("Test", m);


	std::cout << "------------------------\n";
	overlay::overlay o = overlay::overlay();
	std::cout << "\nOverlay : " << o << "\n";

	std::cout << std::boolalpha;
	std::cout << "Points ";
	for(auto vertex : v)
	{
		std::cout << " " << vertex;
	}

;


	std::cout << "\nAre within\n";
//	std::cout << "Point in Square : " << (bool)sq_o.point_in_bounds(p1) << "\n";
	std::cout << "Square Overlay : " << (bool)sq_o.within_bounds(v) << "\n";
	std::cout << "Column Overlay : " << (bool)c_o.within_bounds(v) << "\n";
	std::cout << std::noboolalpha;
	cv::waitKey(0);
}
================================================
CMakeFiles
================================================
--------------------
CMakeLists.txt
--------------------
project(ee2-computer-vision)
SET("OpenCV_DIR" "/usr/share/OpenCV")
MESSAGE( STATUS "=====================================================" )
MESSAGE( STATUS "Setting Directories" )
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)
MESSAGE( STATUS "Setting Directories - done" )
MESSAGE( STATUS "=====================================================" )
find_package(OpenCV REQUIRED)
#include_directories( ${OpenCV_INCLUDE_DIRS} )
MESSAGE(STATUS "=====================================================")
MESSAGE(STATUS "Configuring Libraries")
MESSAGE(STATUS "OpenCV_INCLUDE_DIRS :  ${OpenCV_INCLUDE_DIRS}")
MESSAGE(STATUS "OpenCV_LIBS :  ${OpenCV_LIBS}")
MESSAGE(STATUS "Configuring Libraries - done")
MESSAGE(STATUS "=====================================================")


MESSAGE( STATUS "=====================================================" )
MESSAGE( STATUS "Setting filepaths" )
set(INCLUDE ${PROJECT_SOURCE_DIR}/include/ CACHE FILEPATH "Include")
file(GLOB ALL_FILES
        "${PROJECT_SOURCE_DIR}/src/*.c" ,
        "${PROJECT_SOURCE_DIR}/src/*.cpp" ,
        "${PROJECT_SOURCE_DIR}/include/*.h" ,
        "${PROJECT_SOURCE_DIR}/include/*.hpp"
)

list(APPEND EXCLUDE_FILES
        "${PROJECT_SOURCE_DIR}/src/marker_gen.cpp" ,
        "${PROJECT_SOURCE_DIR}/src/marker_detect_image.cpp" ,
        "${PROJECT_SOURCE_DIR}/src/test_writing.cpp" ,
        "${PROJECT_SOURCE_DIR}/src/marker_detect.cpp"
)
MESSAGE( STATUS "Setting Filepaths - done" )
MESSAGE( STATUS "=====================================================" )

list(REMOVE_ITEM ALL_FILES ${EXCLUDE_FILES})

add_subdirectory(src)
link_directories(include)

include_directories(include)

MESSAGE( STATUS "=====================================================" )
MESSAGE( STATUS "Configuring Custom Targets" )
add_custom_target(clear
        COMMAND ${CMAKE_COMMAND} -E echo "-----------------------------------"
        COMMAND ${CMAKE_COMMAND} -E echo "Emptying /bin"
        COMMAND ${CMAKE_COMMAND} -E echo "-----------------------------------"
        COMMAND ${CMAKE_COMMAND} -E chdir ${PROJECT_SOURCE_DIR} ./scripts/clear_binaries.sh
        COMMENT "Clears /bin"
        VERBATIM

)

add_custom_target(appendix
        COMMAND ${CMAKE_COMMAND} -E echo "-----------------------------------"
        COMMAND ${CMAKE_COMMAND} -E echo "Sending source code to appendix.txt"
        COMMAND ${CMAKE_COMMAND} -E echo "-----------------------------------"
        COMMAND ${CMAKE_COMMAND} -E chdir ${PROJECT_SOURCE_DIR} ./scripts/appendix.sh
        COMMENT "Generates an Appendix containing all code."
        VERBATIM

)
MESSAGE( STATUS "Configuring Custom Targets - done" )
MESSAGE( STATUS "=====================================================" )

MESSAGE( STATUS "=====================================================" )
MESSAGE( STATUS "Configuring Executables" )
add_executable(MarkerDetect ${PROJECT_SOURCE_DIR}/src/marker_detect.cpp ${ALL_FILES})
add_executable(MarkerGen ${PROJECT_SOURCE_DIR}/src/marker_gen.cpp ${ALL_FILES})
add_executable(ImageDetector ${PROJECT_SOURCE_DIR}/src/marker_detect_image.cpp ${ALL_FILES})
add_executable(Test ${PROJECT_SOURCE_DIR}/src/test_writing.cpp ${ALL_FILES})

target_link_libraries(MarkerDetect ${OpenCV_LIBS})
target_link_libraries(MarkerGen ${OpenCV_LIBS})
target_link_libraries(ImageDetector ${OpenCV_LIBS})
target_link_libraries(Test ${OpenCV_LIBS})

target_include_directories(MarkerDetect PRIVATE ${INCLUDE}/include)
target_include_directories(MarkerGen PRIVATE ${INCLUDE}/include)
target_include_directories(ImageDetector PRIVATE ${INCLUDE}/include)
target_include_directories(Test PRIVATE ${INCLUDE/}include)
MESSAGE( STATUS "Configuring Executables - done" )
MESSAGE( STATUS "=====================================================" )
